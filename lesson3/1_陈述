
1. 什么是操作系统? 什么是内核?操作系统有哪几种?内核有哪几种? 
    - 操作系统是管理计算机硬件与软件资源的计算机程序
        -> 主要功能: 进程管理,内存管理,磁盘管理,文件系统,网络通信等
    - 内核是一个操作系统的基石: 内核是操作系统最基本的部分。它是为众多应用程序提供对计算机硬件的安全访问的一部分软件
        -> 内核只是,沟通并合理调度,所有软硬件资源,正常运行正常调度,并为操作系统的扩展性功能提供一个基本环境
    - windows linx mac 安卓
    - 宏观内核(单内核),微观内核,混合内核(二者优点结合)
        -> 宏观内核: 高度集成,性能强悍
        -> 微观内核: 精简,只是保证了最基本的硬件资源合理使用
                    --> 但是可拓展性强
                    --> 只需要你将 相关的驱动挂载进来就可以了
    - 混合 内核: 将二者的优点结合
        -> 保证了可拓展性的同时
        -> 进行了适当的解耦

2. 计算机资源有哪些
    - 硬件资源: 
        总线:
        cpu:
        内存:
        硬盘:
        网卡:
        显卡:
        同种i/0 设备: 显示器,打印机,键盘鼠标

    - 软件资源:
        cpu管理程序: 暨进程管理
        内存管理程序: 
        硬盘管理程序
        显卡管理程序
        网卡管理程序
        i/o设备管理程序
        其他安全组件
        驱动程序
    
3. 宏内核:
     将所有的内核代码 ,编译链接,形成一个全息的可执行程序
     高度耦合,不可拓展,每一次内核的更新迭代,或者采用全新的设备,都需要进程重新编译
     没有模块化,没有扩展性,高度耦合,一处出错,全盘结束
     ----------------------------------------------------
     唯一优点: 性能极好
                -> 组件相互调用,性能高
4. 微内核:  提倡内核功能尽可能的少,仅仅只有进程调度,处理中断,内存空间映射,进程通信等
        - 最简答,最基本的内核,还不能完成进程调度,内存管理,磁盘管理的功能
        --> 开发者 把这些 进程调度,磁盘管理等功能
        --> ** 做成了服务进程 ** (windows 系统服务,linux 系统进程) 

        微内核因为 其余的管理程序,并不是 集成在一起的,
        所以在进行处理动作是,需要在多个程序间进行通信
        所以就无法做到像 宏内核那样高度集成导致的随意调用其他系统处理模块
        从而导致 性能稍微降低

        --> 可拓展性强,但是性能不高,无法应对商业化需求

5.分离硬件的相关性
    这样考虑:
        我们要写的内核,可能今天跑在 Intel 的 i3 cpu上
        也可能明天跑在 AMD的 线程撕裂者上
        更有可能跑在古早的 8086上
        补充: 不同cpu的平台环境是不一样的,就比如 你买 inter的cpu主板那一套就必须适配intel
            你买AMD的就只能适配AMD
            所以,要考虑不同平台下,当前所写内核的可移植性

    如何保证呢:
        最基本的就是:
            把所有和硬件相关的操作,完全的剥离出来: 做成硬件层
            硬件层,负责管理沟通,调度使用 不同平台的硬件资源
                -> 并且为上层的其他 内核软件 提供相应的接口
        硬件层如何保证可移植性?
            个人猜测:
                首先 cpu厂商遵循行业标准: 在自家已经成熟的架构的基础上进行开发迭代
                其次 cpu厂商将相关的 架构信息,底层地址,规范化,并公布
                再次 系统厂商,或者其他硬件厂商,共同遵守这个行业规范,
                    -> 在 众所周知,共同遵守的大环境下,进行各自的开发
                最终 通过 完备且周到的考虑(穷举不同平台的不同硬件环境) ,结合当前硬件所处环境
                    -> 选择一个适配的进行使用即可
        硬件层保证了适配性,暨可移植性之后:
            硬件层完全剥离,单独成层
            硬件层,向上层提供相应的接口
            这样,上层就可以完全不关心,最底层的硬件情况
            上层全心全意,实现本层所需功能 : 相信并且绝不质疑底层硬件层的失误

=====================================================
7. 本内核的大结构
    1. 采取混合内核模式
    2. 抽象分层: 3大层
        1. 内核接口层: 定义一系列接口
            => 主要内容:
                1. 定义一套unix接口子集,并且使其大致定义出操作系统的功能
                2. 该套接口的code, 就是检查参数是否合法,
                    -> if error :返回错误
                    -> else: 交给下层完成    相关内核功能的核心代码
        2. 内核功能层: 主要完成各种实际功能
            => 划分各个功能模块:
                1. 进程管理: 实现继承的创建,销毁,调度 
                            -> 具体就是要设计几套 数据结构,用来表示和组织进程
                            -> 以及实现一个简单的进程调度算法
                2. 内存管理:    只实现 内存池管理
                            -> 第一种内存池: 页面内存池
                            -> 第二种内存池: 任意大小的内存池
                3. 中断管理: 
                            -> 就是把一个中断回调函数,安插到相关数据结构中
                            -> 一旦发生相关中断,就会调用这个函数 
                            ====> poll slelect 的回调函数
                4. 设备管理:    重点难点
                            -> 需要设计一系列的数据结构表示,驱动程序模块,驱动程序本身,驱动程序创建的设备
                            -> 并把这三这组织在一起
                            -> 还要实现 创建设备,销毁设备,访问设备的代码
                            -> 最终达到,通过调用驱动程序,从而操作设备的目的

        3. 内核硬件层: 主要包括一个具体硬件平台的相关代码
                1. 初始化: 初始化代码 是内核被夹在都内存中最先需要运行的代码(0号进程)
                            -> eg: 初始化少量的设备,cpu,内存,中断的控制,内核用于管理的数据结构等
                2. cpu控制: 提供cpu模式设定,开关中断,读写cou特定寄存器等功能的代码
                3. 中断处理: 保存中断上下文,调用终端回调函数,操作中断控制器等
                4. 物理内存管理:    分配内存,释放大块内存,操作MMU映射,操作CACHE等
                5. 平台的其他相关功能:
                其他组件:
                    文件系统,网络组件,其他功能组件,作为虚拟设备,交给 内核管理 
                    eg: 
                            文件系统: 写一个文件系统虚拟设备驱动 来完成文件系统的功能
                            网络: 虚拟网络设备驱动来完成  网卡的相关功能

8. 我们的内核很简单,但是是混合内核
    在极度简单的微内核基础上,
    通过挂载,其他的,已经写好的 驱动程序 
    使得其他的驱动程序,成为了内核的一部分

    ======> 重点:
        挂载后的驱动程序: 是作为内核的一部分的,
                        并不像传统微内核一样,座位服务进程运用
                        ===> 暨吸取了微内核的优点 --> 可拓展性强
                        ===> 又吸收了宏内核的优点 --> 挂载后,成为内核的一部分,使得代码高度耦合,性能强筋
------------------------------------------------------
宏内核: 所有功能高度耦合 , 全部都工作在内核
微内核: 高度解耦,只有一个最基本最简单的内核,其余服务全部在用户空间,以服务进程的身份进行运行
        --> 所以 性能很差
        --> 各个服务进程之间 在用户态 通过 进程间通信机制来进行沟通并处理
混合内核:   先高度解耦,模仿微内核,再,将其余功能挂载进来,在内核空间运行其他关键功能
        --> 优点结合
windows 内核 : NT
Linux 内核   : CentOs Ubentu
mac     内核 :
    基本上都是混合内核
------------------------------------------------------

