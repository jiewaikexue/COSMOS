
这篇文章开始烧脑了，全文汇编，第一次看这篇云里雾里不知所云，汇编基础差决心回头花了3个礼拜啃完了《汇编原理》，这周再次看这篇又理解了些。
和《汇编原理》书上介绍的8086不同，这篇里面是32位的x86，不过底层原理差不多。

对着这篇文章结合源码，画了一份visio流程图，流程上清晰了些，总结如下：




1. 实现了被GRUB识别的GRUB Head，GRUB Head里面做了2件事：
1）inithead.c，从内存中查找和拷贝2个bin文件（二级引导器和BIOS中断服务程序的bin文件）到指定位置；
2）跳转到物理地址0x200000执行二级引导器代码（第一步已经将机器码拷贝到这里）。




2. 二级引导器 ldrkrl32.asm (0x200000)
1）引导主函数ldrkrl_entry()   （暂未实现）；
2）准备BIOS中断服务程序调用框架，核心是通过 jmp 0x18:0x1000 跳转到 BIOS中断服务程序（readintsve.asm）所在位置执行。

3. BIOS终端服务程序 readintsve.asm (0x18:0x1000)
1）首先进入16位实模式；
2）实模式下，有一个func_table，通过这些函数可以获取内存、硬盘和显卡等硬件信息；
3）最后返回32位保护模式，恢复进入前保存的EIS+EIP返回调用前的32位保护模式状态。

思考题：_start和_entry的用途是GRUB用来识别硬件厂商客制化的GRUB头的，作为厂商二级引导器的入口，详细信息上面已经有很多大佬解释的很详细就不写了。