
新名词:
1. GRUB: linux 的一款引导程序管理器(简单的GUN界面)
    ==> 传统的 引导程序管理器
2. EFI (UEFI):  新兴的引导程序管理器
    ==> 全程:统一可扩展固件接口
    ==> 特点: 你可以看自己笔记本的 bios 
                里面可以自己设置
                UEFI: 可以更加快速的启动

3. MBR: 主引导记录:
        在每一整块硬盘 的: 前 512 个字节
        446 + 64 + 2 
        引导程序 + 分区管理 +校验

4. GPT: GUID磁盘分区表（GUID Partition Table），其含义为“全局唯一标识磁盘分区表。
        ==> 新兴磁盘分区
        ==> 相比于MBR，它最大的亮点就是可以划分很多个分区，不止4个。

全新尝试:
    重点:  如何 在开机的时候,让引导程序,引导到 我们自主编写的内核?

    难点:  本段代码,不能直接用c ,只能使用汇编代码
            --> 因为你还没有开机,你还没有运行起来 你的操作系统
            --> 你的编译器,是不工作的
            --> 此时 ,你只能 使用汇编语言,让 主板中的bios ,通过硬件芯片去执行 你想做的工作
    回顾:   如何控制显存?
    控制显卡输出字符:!
        显卡/集显 通用标准: VESA                      
                -> VESA标准下: 2种工作模式
                        1. 字符模式
                        2. 图形模式
        显卡工作模式: 字符模式
                ++++++++++++++++++++++++++++++++++++        
                + 把屏幕 分成 24行
                + 每一行 80 个 字符
                + 显存起始地址 0b8000
                + 存储方式: 每个字符 = 一个字节 ASCII码 + 一字节 rgb颜色
                ++++++++++++++++++++++++++++++++++++  





遗留问题:
        entry.asm中 有很多东西 都是后面才介绍的
                1. GRUB 2个版本的引导头
                2. 设置CPU工作模式
                3. 初始化CPU集尘器 和 c语言的 运行环境
                4. GDT_START cpu工作模式所需要的的数据
                5. 该汇编代码,从外部调用main函数 
                        --> 最终由 nasm和GCC分别连接成模块
                        --> 再有LD连接器链接在一起,形成可执行程序文件
        main.c:
                1. 该main函数 是 Hello OS的main 函数
                2. 且 该printf 也不是 stdio.h内的函数
                        -> 需要自己实现
