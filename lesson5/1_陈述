本节主要是 深入了解硬件层的CPU


1. X86 架构下cpu工作模式
    1. 实模式
    2. 保护模式
    3. 长模式

2. 实模式: 暨实地址模
        --> 运行真实的指令,直接执行指令的真实功能 (完全相信指令)
        --> 发往内存的地址是真实的,且不加任何限制 (真实地址完全开放)
3. 实模式下访问内存: 16位机器
    分段式
    段基址 << 4 + 段内偏移 = 真实地址     
    段基址左移4位,形成了20位及地址,然后 + 偏移量的16位 最终形成 20位物理地址 --> 可寻址1M

4. 中断: 暨终止执行当前程序,转而跳转到另一个特定的地址,去执行特定的代码
        硬件中断: 中断控制器给CPU发送一个电子信号,CPU作出应答,随后CPU进行对应的操作
        软件中断: CPU执行了  INT指令 , 这个指令后面通胀会跟一个常数,该常数就是软中断号,从而去中断表内进行操作
        
    实模式中断:
        中断向量表: 该表的地址和长度,由CPU的她的顶寄存器 IDTR指向
                    IDTR寄存器: 中断表的起始地址 + 中断表的长度 === 类似数组

        CPU根据IDTR寄存器中的信息,从而装载CS,IP寄存器,从而响应中断

5. x86架构有20根地址总线(16位机器): 理论上最大寻址应该是 2^16,如何实现2^20的寻址
    两个寄存器:段寄存器 ,段内偏移寄存器 : 同时段寄存器 << 4


6 实模式的缺点: 1. 对任何指令不加区分的执行 2. 对任何内存地址都不做限制
7. 保护模式:
    1. 为了区分哪些指令 and 哪些资源 可以被访问 : cpu实现了特权级
        ==================================================
        + 特权级:
        +   1. R0: 可以执行所有的指令
        +   2. R1 ~ R3: 可执行指令集合范围主键减小 
        ==================================================
8. 由于16位扩展到了 32位: 向下拓展是必然的,但是需要考虑向下兼容
    --> 32 位的段及地址和段内偏移是一定在 16位寄存器放不小的
    ---> 引入段描述符
            ============================================
            + GDT: 全局段描述符
            + LDT: 局部段描述符(可以有多个) 
            +           -GDT: 操作系统特供
            +           - 保护模式下 CPU寻址时, 段寄存器 + GDTR寄存器定位到描述符
            +                   --> cpu 允许访问 且 操作系统允许访问
            ============================================

    -----> 段寄存器,不在存放段基地址 ,存放的是具体段描述符的索引

9. 保护模式平坦模型:
    分段模式有很多缺陷: 1. 交换内存 swap是 效率低下
                       2. 会产生大量的内存 外碎片
    并且: X86: 并不能直接启用分页模型: 而是要在分段模型的签一下,根据需要来觉得是否开启分页
            暨 X86 一来先进性段映射 让毕业在进行页面映射

        linux绕开了段式:直接采用段页式





10. 保护模式的中断: 权限检查 and 特权级切换
    实模式中断: 不需要做权限检查
    保护模式 需要做权限检查 (R0 ~ R3)
    
        中断门:  1 + DPL + 0 + TYPE
                =========================
                + 1: 在内存中必须为1
                + DPL: 中断门描述符特权级别
                + 0 : 系统描述符
                + TYPE:  
                +      第一个bit:    1: 32位  0 : 16位
                +      第二,三个bit: 1 1
                +      第四个bit : 
                +                   0: 中断门 
                +                   1: 陷阱门
                =========================
    保护模式产生中断之后的过程:
        1. 检查中断号 是否合理 (0~ 255)
        2. 检查描述符类型 : 是中断门 或者 陷阱门
        3. 判断是否是系统描述符
        4. 检查是不是在内存中
        5. 做 权限检查 :
                CPL: 当前特权级别
                DPL: 中断门的特权级别
                if CPL < DPL && CPL < 中断门的段选择子指向的段的DPL   {
                        指向该段 (当前特权级 完全可以执行目标段特权级)       
                }else if  == {
                    同上
                } else {
                    进行特权级切换 ,也就是栈切换
                    切换到 段选择字的DPL 
                }

10. 切换到保护模式: windows 7 开机有一个安全模式
    x86cpu在第一次加点和每一次 reste后 都会自动进入 实模式
    
    切换到保护模式: 
            ===================================
            + 1. 准备全局标书符表: GBT
            + 2. GDRT指向 GDTR
            + 3. 设置CR0寄存器, 开启保护模式
            + 4. 执行长跳转, 加载cs段寄存器,暨段选择子
            + why要进行长跳转?
            +       ==> 我们无法直接或者简介 mov一个数据到 cs 寄存器 ,
            +           因为刚开启保护模式 cs 的影子寄存器,中的值还是 实模式下的值
            +           所以需要告诉CPU加载新的段信息
            +       ==> 接下来 CPU发现CRO寄存器的第0位是 1,就会按照GDRT的知识,到全局描述符表
            +           把新的段描述符信息 加载到cs 影子寄存器
            +       ==> 暨长跳转,通过直接跳转到 GDRT 指向的段描述符,从而刷新影子寄存器
            ===================================





长模式:
    长模式又名AMD64
    长模式弱化了 段模式管理,只保留了权限级别的检查
        => 忽略了段基址和段长度
        => 地址的检查交给了 MMU,分页管理

    长模式和保护模式的区别
        长模式在保护模式的基础啊上,无非就是拓展了 寄存器的长度
    长模式的切换
        ==============================================
        + 准备 长模式的 GBT
        + 准备长模式下的 MMU页表,开启 分页模式
        + CR3 指向页表物理地址
        + GDTR指向 GBT
        + 相关寄存器,开启长模式 ,保护模式,以及分页模式
        + 进行长跳转,避免了 保护模式下影子寄存器的数据
        +   => 长跳转可以刷新影子寄存器!
        ==============================================
    

他人总结:
    bios引导后 系统进入最简单,特权最大的实模式;
    而后告知CPU 切换到保护模式,并允许在 R0 级别
    后续的用户进程 一班是 R3 
