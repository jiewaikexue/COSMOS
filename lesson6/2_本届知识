
1. MMU 你可以理解为 "一夫当关" 卡在了cpu和总线之间
2. 保护模式的平坦模型: 可以成功绕过  "分段式"
3. MMU 多级页表模式图:https://static001.geekbang.org/resource/image/2d/yf/2df904c8ba75065e1491138d63820yyf.jpg?wh=5045*3212
4. 保护模式: 只支持32位
5. 保护模式: 两种分页粒度
        1. 4kb
        2. 4MB
6. 长模式: 两种分页粒度 
        1. 4kb
        2. 2MB


7. 分页式: 必须开启MMU
8. 开启MMU: 必须是保护模式 或者 实模式
9. 开机第一时间: bios 引导系统,进入的 是 "实模式"


10开启mmu步骤:
    ===================================================
    + 1. 模式转化: 从实模式 --> 保护模式/实模式
    + 2. "软硬件结合" MMU: 准备软件相关,并把他们放入 物理内存
    +               1. 页表数据
    +               2. 页目录数据:
    +               3. TBL结构
    + 3. 把顶级页目录的物理内存地址 : 赋值给CR3 寄存器
    ```
        mov eax, PAGE_TLB_BADR ;页表物理地址
        mov cr3, eax
    ```

11. MMU会失败吗? 又该怎么办呢?
    eg: 绝对有可能，
        例如，页表项中的数据为空，用户程序访问了超级管理者的页面，向只读页面中写入数据。这些都会导致 MMU 地址转换失败。
    eg:
    而对于老师说的，mmu无法映射物理地址时，有几种原因
      ====================================================
        1.访问了受内核保护的页面，或者访问了只读的页面（比如c语言中存储字符串字面量和const变量的段），此时内核会抛出段错误
        2.页面和页框没有产生映射关系，但是数据页已经被其他进程加载到内存中了，此时只需要建立页面和页框的映射关系，称为次级缺页中断
        3.页面和页框没有产生映射关系，数据页也没有被加载到内存中（在磁盘上），此时需要发生磁盘io从磁盘中加载页到内存中，还需要建立页面和页框的映射关系，称为严重缺页中断。

        除了第一点，第二第三都会以内核降低自身运行速度来修复，也就是老师说的，通过中断形成页表映射，然后再重新执行引起中断的命令（此时数据页已经在内存中并且建立映射关系了）。
      ====================================================
    处理方式:
    1. 停止MMU转换
    2. 把转换失败的 虚拟地址 写入到CPU的 CR2寄存器
    3. MMU出发14号中断,使CPU停止当前治疗
    4. 执行中断处理代码,
    5. 中断返回,继续处理


11 MMU 如何实现
=====================================

MMU:
  设计思路:
    虚拟地址到物理地址直接做映射,则映射关系大到无法接收,维护成本太高.
    虚拟段基址映射到物理段基址,看似可以,但是段长度各不相同,并且粒度可能会很大.
    因此把虚拟地址和物理地址空间都分成同等大小的块,按照虚拟页和物理页进行映射和转换,地址转换表中存放虚拟页地址对应的物理页地址即可.
  实现思路:
    纯硬件实现没有灵活性,用软件实现太低效,因此使用 "软硬件结合" 的方式.
        ==> 用硬件电路逻辑实现地址转换器件,
        ==> 硬件来解析: 接受的虚拟地址和地址关系转换表,输出物理地址.
为什么需要多级页表:
  每个进程都有自己的页表,多级页表可以省掉大量未映射页表占用的空间,为null则说明后面的页都没有使用.
  虚拟地址由虚拟页号和虚拟页号偏移组成,多级页表查找时可以使用索引.