
linux 虚拟内存机制

1. 三种管理策略
    1. 分段式
    2. 分页式
    3. 段页式
2. 分段式的缺陷:
    - swap交换分区时,效率低下
    - 段式内存,每次分配是分配很大的一块, 这样很可能出现内存外碎片
    ========================
    + 外碎片: 外部无法使用的内存(最后一个包子吃不了了,最多只能吃掉半个)
    +           - 特点 无法分配出去的空闲页
    + 内碎片: 胃里 的食物 并不是完全没有空隙的,空隙你可以理解为内碎片
    +           - 已经分配 出去的, 内部不完全连续使用 有漏
    ========================
    + 反碎片技术:
    +           1. 虚拟内存可移动区域: 
    +           2. 内存碎片整理技术:
    ========================
    + 1. 虚拟内存可移动区域:
    +       技术原理: 分为两个区域
    +               - 可移动区域:
    +               - 不可移动区域:
    +               - 特点: 不可移动区域的页 一定 不被允许,移动到 可移动区域
    +               - 比喻: 酒店住房,双人间, 住满了的就不动,你别换了, 没有住满的,单人,或者空房,其他人是可以入住拼单的
    ------------------------
    + 2. 内存碎片整理:又称,内存缩紧
    +               - 使用: 必须 选择 特定参数 重新编译内核 
    +                      == 编译内核时，如果需要内存碎片整理功能，必须开启配置文件“mm/Kconfig”定义的配置宏CONFIG_COMPACTION，默认开启。
    +               - 原理: https://zhuanlan.zhihu.com/p/565464633
    +               如图 : https://pic2.zhimg.com/80/v2-9e953acf20772a34c4c365858cbbdd51_720w.webp 
    +                       == 重点: 两个扫描器
    +                               1. 迁移页面扫描器:
    +                                               - 从 内存底部区域 向 内存顶部区域 扫描
    +                                               - 扫描对象: 可移动页面
    +                                               - 组成: 所有扫描到的 可移动的,已分配出去的页面 组成一个链表
    +                               2. 空闲页面扫描器: 
    +                                               - 从 内存顶部 区域 向内存底部区域进行扫描
    +                                               - 扫描对象: 空闲页面 组成一条链表
    +                               3. 两个扫描器 在内存中间区域相遇: (重点)
    +                               4. 最后,把 可移动的页 移动(复制)到 空闲页 : ==> 空闲页和可移动也交换位置,这样 可以尽可能凑出来 连续页面
    +               如图: 大致流程 https://pic1.zhimg.com/80/v2-95807c89e6c2ccb938d709b400cde218_720w.webp
    ================================================================================================


2. 为什么要引入虚拟内存机制? 结合cpu工作模式
    实模式下: cpu完全信任 任意内存操作,并且直接影响物理内存
    保护模式: 也就是虚拟内存机制
    为什么引入?
        1. 不安全: 直接操作真实物理地址非常危险
                    - 实模式下  地址空间不隔离,直接操作物理内存,很容易写入到一些非常敏感的地址
        2. 相互影响: 多个进程,直接操作同一块真实的物理地址,是可能相互影响的
        3. 效率低下: 如果内存空间使用完毕,如果在swap的策略下,需要整块内存完全换出
                    - 效率一场地下
        4. 程序地址不确定: 不同的程序的 起始位置,可能随着加载顺序的不同,倒置程序入口地址完全不一致
                    - 非常恐怖,没有提供一个标准

3. 分页式: 解决了 分段式的缺点
    - swap交换效率低下: 分也是swap交换的内容很小 ,效率大大提高
    - 外碎片: 分也是 并不需要每次划分超大的,内存段出去,只需要小小的划分

    缺点: 
        - 由于基本上 每一页的大小固定为4kb, 为了每一页都和实际真实物理内存进行映射
        - 就需要对 4GB内存 按照每4KB 进行划分 ≈ 4M  
                    ==> 同时考虑 每一个PCB都有自己独立的页表结构
                    ==> 4M * pcb 个数
        - 最终形成了 一张超级大的页表
        - 超级占用内存2
    分页式改进: 
        1. 多级页表结构: 解决了 单页表的巨大化问题
                -   1. 一级页表: 一定存在,且逻辑覆盖所有内存区域
                -   2. 后续多级页表: 使用时创建

            ====>  多级页表的缺点:
                多级页表,也就意味着,需要经过MMU的多次映射
                每一次映射,都意味着 性能损失
                --> 映射次数 增加, 性能损失扩大
            ====> 解决办法: TBL(快表机制) (类似于页表缓存)

3. 段页式:  分段式 and 分页式的结合
    -- 注意L分页式其实已经很成熟了
    -- linux 内核采用段页式,其实就是 因为历史因素
    -- 但是!: linux 利用ELF文件的机制,成功的绕开了 段氏
    -- ELF 可执行程序 :程序装载运行视角, 利用 MMU 进行 段基址映射
                ===> 但是  所有段 的基地址 都是0
        然后在利用MMU 进行分页式映射,映射到真实内存


4. 逻辑地址,虚拟内存地址,真实内存地址
    ELF文件中存储的 是: 逻辑地址 (只有相对位置) --> x86按照标准,将各个段映射成规定的虚拟地址
            --> 4GB 标准虚拟内存空间划分,这些都是 虚拟内存地址
            --> 逻辑地址: 只有相对位置的,没有映射的地址

    虚拟地址: 逻辑地址 经过MMU 映射
    真实地址: 


5. 缺页中断:
    在进行内存映射后,cpu根据页表标志位,发现 当前页并不在内存中
    从而引发缺页中断


6 MMU到底是什么? 
    每一个 CPU核心上基本上都有一个MMU
    注意: 现代3大主流操作系统(linux 内核,nt内核,darwin内核)基本上都强制要求 在持有MMU芯片的硬件环境基础

    MMU 负责将 虚拟内存地址,映射成为真正的物理内存地址
    --> CPU 并不负责 虚实地址转化
    --> CPU 可以更加专注的,从事运算处理
    ----> 整个系统进一步更加高效


    ============================================
    整个CPU内部在工作时,使用的都是虚拟地址
    一旦CPU发出,都会被 MMU 拦截
    转换成真正的 真实内存地址,在去和 内存进行存取沟通
    ============================================


7. MMU 一个真正的 "软硬件"
    页表/段表: 一班都是在内核管理,太大了可以swap到磁盘上
    TBL: 内存中
    多级页表查询逻辑
    电学芯片

8.实模式并不需要 使用到 MMU,因为虚拟内存地址是 保护模式引入的
9. 如何理解linux绕开了 段氏内存映射直接到达页式内存
    长模式: 弱化了 段氏管理
        保留了 权限级别
        拓展了寄存器长度
